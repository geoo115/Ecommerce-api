name: CI/CD Pipeline with Load Testing

concurrency:
  group: ci-${{ github.ref_name }}
  cancel-in-progress: false

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Load test type to run'
        required: false
        default: 'comprehensive'
        type: choice
        options:
          - health
          - comprehensive
          - stress
          - all

env:
  GO_VERSION: '1.23.0'
  NODE_VERSION: '18'
  REGISTRY: 'docker.io'
  IMAGE_NAME: 'geoo115/ecommerce-api'

jobs:
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: ecommerce_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
      
      # Cache temporarily disabled due to corruption
      # - name: Cache Go modules
      #   uses: actions/cache@v4
      #   with:
      #     path: ~/go/pkg/mod
      #     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
      #     restore-keys: |
      #       ${{ runner.os }}-go-
      
      - name: Debug environment
        run: |
          echo "Go version:" && go version
          echo "Listing first 20 module packages:" && go list ./... | head -20
          echo "Total packages:" $(go list ./... | wc -l)
          echo "Working directory contents:" && ls -1 | head -50
          echo "Date:" && date -u
          echo "Runner OS:" $RUNNER_OS
          echo "Git SHA:" $GITHUB_SHA
      
      - name: Install psql client & bc
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client bc
      
      - name: Wait for Postgres readiness
        env:
          PGPASSWORD: test_password
        run: |
          for i in {1..20}; do
            if pg_isready -h localhost -p 5432 -U postgres; then
              echo "Postgres is ready"
              break
            fi
            echo "Waiting for Postgres ($i/20)..."
            sleep 2
          done
          pg_isready -h localhost -p 5432 -U postgres || (echo "Postgres not ready in time" && exit 1)
      
      - name: Download dependencies
        run: |
          echo "Starting dependency download..."
          go mod download -x
          echo "Dependencies downloaded successfully ‚úì"
      
      - name: Verify database connection
        env:
          PGPASSWORD: test_password
        run: |
          echo "Testing database connection..."
          psql -h localhost -p 5432 -U postgres -d ecommerce_test -c "SELECT version();"
          echo "Database connection verified ‚úì"
      
      - name: Run Go vet
        run: |
          echo "Starting Go vet..."
          echo "Packages to vet:"
          go list ./... | grep -v /cmd/ | head -10
          echo "Running go vet..."
          go vet $(go list ./... | grep -v /cmd/)
          echo "Go vet completed successfully ‚úì"
      
      - name: Run Go fmt check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "The following files are not formatted:"
            gofmt -s -l .
            exit 1
          fi
      
      - name: Run tests with coverage
        env:
          DATABASE_HOST: localhost
          DATABASE_PORT: 5432
          DATABASE_USER: postgres
          DATABASE_PASSWORD: test_password
          DATABASE_NAME: ecommerce_test
          DATABASE_SSLMODE: disable
          JWT_SECRET: test_jwt_secret_for_ci
        run: |
          echo "Starting tests with environment:"
          echo "DATABASE_HOST: $DATABASE_HOST"
          echo "DATABASE_PORT: $DATABASE_PORT" 
          echo "DATABASE_USER: $DATABASE_USER"
          echo "DATABASE_NAME: $DATABASE_NAME"
          echo "DATABASE_SSLMODE: $DATABASE_SSLMODE"
          echo "Running go test..."
          if ! go test $(go list ./... | grep -v /cmd/) -coverprofile=coverage.out -covermode=count -v 2>&1 | tee test_output.log; then
            echo "‚ùå Tests failed! Last 50 lines of output:"
            tail -50 test_output.log || echo "No test output found"
            echo "‚ùå Full test output:"
            cat test_output.log || echo "Could not read test output"
            exit 1
          fi
          echo "‚úÖ Tests passed, generating coverage report..."
          go tool cover -func=coverage.out
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella
      
      - name: Check coverage threshold
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
          echo "Total coverage: $COVERAGE%"
          if (( $(echo "$COVERAGE < 73.0" | bc -l) )); then
            echo "Coverage is below 73% threshold"
            exit 1
          fi
          echo "‚úÖ Coverage check passed: $COVERAGE% (threshold: 73%)"
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            coverage.out
            *.log
          retention-days: 30

  performance-test:
    name: Performance Regression Tests
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
      
      # Cache temporarily disabled due to corruption
      # - name: Cache Go modules
      #   uses: actions/cache@v4
      #   with:
      #     path: ~/go/pkg/mod
      #     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
      #     restore-keys: |
      #       ${{ runner.os }}-go-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run performance benchmarks
        run: |
          go test -bench=. -benchmem $(go list ./... | grep -v /cmd/) > benchmark_results.txt
          cat benchmark_results.txt
      
      - name: Run performance regression tests
        run: |
          go test -run=TestHealthCheckPerformance -v ./api/handlers/
          go test -run=TestMetricsEndpointPerformance -v ./api/handlers/
      
      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: benchmark_results.txt
          retention-days: 30
      
      - name: Check for performance regressions
        run: |
          if grep -q "FAIL" benchmark_results.txt; then
            echo "Performance regression detected!"
            exit 1
          fi
          if grep -q "ns/op" benchmark_results.txt; then
            echo "Benchmarks completed successfully"
          else
            echo "No benchmark results found"
            exit 1
          fi

  load-test:
    name: Load Testing
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
      
      - name: Set up Node.js for k6
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install k6
        run: |
          curl -s https://dl.k6.io/key.gpg | sudo apt-key add -
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6
      
      # Cache temporarily disabled due to corruption
      # - name: Cache Go modules
      #   uses: actions/cache@v4
      #   with:
      #     path: ~/go/pkg/mod
      #     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
      #     restore-keys: |
      #       ${{ runner.os }}-go-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Build application
        run: go build -o ecommerce-api main.go
      
      - name: Determine test type
        id: test-type
        run: |
          if [ "${{ github.event.inputs.test_type }}" != "" ]; then
            echo "test_type=${{ github.event.inputs.test_type }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "test_type=health" >> $GITHUB_OUTPUT
          else
            echo "test_type=comprehensive" >> $GITHUB_OUTPUT
          fi
      
      - name: Run load tests
        run: |
          if [ -f "run_load_tests.sh" ]; then
            chmod +x run_load_tests.sh
            ./run_load_tests.sh ${{ steps.test-type.outputs.test_type }} -d 2m
          else
            echo "Load test script missing - skipping load tests"
          fi
        env:
          CI: true
      
      - name: Upload load test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: load-test-results-${{ steps.test-type.outputs.test_type }}
          path: |
            load_test_logs/
            load_test_reports/
          retention-days: 30
      
      - name: Generate load test summary
        if: always()
        run: |
          echo "## Load Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Test Type: ${{ steps.test-type.outputs.test_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- Duration: 2 minutes" >> $GITHUB_STEP_SUMMARY
          echo "- Trigger: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "load_test_reports" ]; then
            echo "### Test Results" >> $GITHUB_STEP_SUMMARY
            ls -la load_test_reports/ >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -f "load_test_logs/server.log" ]; then
            echo "### Server Logs (Last 20 lines)" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -20 load_test_logs/server.log >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  build:
    name: Build & Docker
    runs-on: ubuntu-latest
    needs: [test, performance-test, load-test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        if: github.ref == 'refs/heads/main' && github.repository == 'geoo115/Ecommerce-api'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
        continue-on-error: true
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false  # Temporarily disable push until Docker secrets are configured
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Docker cache temporarily disabled due to corruption
          # cache-from: type=gha
          # cache-to: type=gha,mode=max
      
      - name: Generate artifact attestation
        if: github.ref == 'refs/heads/main'
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  deploy-staging:
    name: Deploy to Staging (Render)
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/develop'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to Render Staging
        id: deploy
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID_STAGING: ${{ secrets.RENDER_SERVICE_ID_STAGING }}
        run: |
          echo "üöÄ Deploying to Render staging environment..."
          DEPLOY_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            "https://api.render.com/v1/services/$RENDER_SERVICE_ID_STAGING/deploys" \
            -d '{"clearCache": false}')
          
          echo "Raw deploy response: $DEPLOY_RESPONSE"
          DEPLOY_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.id // empty')
          if [ -z "$DEPLOY_ID" ]; then
            echo "Failed to extract deploy id" >&2
            exit 1
          fi
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Staging deployment triggered (id=$DEPLOY_ID)"
          echo "url=https://your-staging-app.onrender.com" >> $GITHUB_OUTPUT
      
      - name: Wait for Staging Deployment
        if: github.ref == 'refs/heads/develop'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID_STAGING: ${{ secrets.RENDER_SERVICE_ID_STAGING }}
        run: |
          echo "‚è≥ Waiting for staging deployment to become live..."
          for i in {1..40}; do
            STATUS=$(curl -s -H "Authorization: Bearer $RENDER_API_KEY" -H "Accept: application/json" \
              "https://api.render.com/v1/services/$RENDER_SERVICE_ID_STAGING" | jq -r '.service.deploy.status // .service.status // "unknown"')
            echo "Attempt $i: status=$STATUS"
            if [ "$STATUS" = "live" ]; then
              echo "‚úÖ Staging service is live"
              break
            fi
            if [ "$STATUS" = "failed" ] || [ "$STATUS" = "canceled" ]; then
              echo "‚ùå Deployment failed (status=$STATUS)"
              exit 1
            fi
            sleep 15
          done
          
          if [ "$STATUS" != "live" ]; then
            echo "‚ùå Staging did not reach live state in time"
            exit 1
          fi

  deploy-production:
    name: Deploy to Production (Render)
    runs-on: ubuntu-latest
    needs: [test, build, performance-test]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to Render Production
        id: deploy
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID_PRODUCTION: ${{ secrets.RENDER_SERVICE_ID_PRODUCTION }}
        run: |
          echo "üöÄ Deploying to Render production environment..."
          DEPLOY_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            "https://api.render.com/v1/services/$RENDER_SERVICE_ID_PRODUCTION/deploys" \
            -d '{"clearCache": false}')
          
          echo "Raw deploy response: $DEPLOY_RESPONSE"
          DEPLOY_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.id // empty')
          if [ -z "$DEPLOY_ID" ]; then
            echo "Failed to extract deploy id" >&2
            exit 1
          fi
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Production deployment triggered (id=$DEPLOY_ID)"
          echo "url=https://your-production-app.onrender.com" >> $GITHUB_OUTPUT
      
      - name: Wait for Production Deployment
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID_PRODUCTION: ${{ secrets.RENDER_SERVICE_ID_PRODUCTION }}
        run: |
          echo "‚è≥ Waiting for production deployment to become live..."
          for i in {1..60}; do
            STATUS=$(curl -s -H "Authorization: Bearer $RENDER_API_KEY" -H "Accept: application/json" \
              "https://api.render.com/v1/services/$RENDER_SERVICE_ID_PRODUCTION" | jq -r '.service.deploy.status // .service.status // "unknown"')
            echo "Attempt $i: status=$STATUS"
            if [ "$STATUS" = "live" ]; then
              echo "‚úÖ Production service is live"
              break
            fi
            if [ "$STATUS" = "failed" ] || [ "$STATUS" = "canceled" ]; then
              echo "‚ùå Deployment failed (status=$STATUS)"
              exit 1
            fi
            sleep 10
          done
          
          if [ "$STATUS" != "live" ]; then
            echo "‚ùå Production did not reach live state in time"
            exit 1
          fi

  post-deployment-tests:
    name: Post-Deployment Health Check
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Health Check Production
        run: |
          echo "üè• Running post-deployment health checks..."
          sleep 30
          
          HEALTH_URL="https://your-production-app.onrender.com/health"
          for i in {1..10}; do
            if curl -f -s "$HEALTH_URL" > /dev/null; then
              echo "‚úÖ Health check passed"
              break
            else
              echo "‚è≥ Health check failed, retrying in 30s... (attempt $i/10)"
              sleep 30
            fi
          done
          
          curl -s "$HEALTH_URL/detailed" | jq '.' || true
      
      - name: API Smoke Tests
        run: |
          echo "üß™ Running API smoke tests..."
          BASE_URL="https://your-production-app.onrender.com"
          
          # Test basic endpoints
          curl -f "$BASE_URL/health" || exit 1
          curl -f "$BASE_URL/categories" || exit 1
          curl -f "$BASE_URL/products" || exit 1
          
          echo "‚úÖ All smoke tests passed"

  performance-alert:
    name: Performance Alert
    runs-on: ubuntu-latest
    needs: load-test
    if: failure() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    steps:
      - name: Send performance alert
        run: |
          echo "‚ö†Ô∏è Performance test failed!"
          echo "Check the load test results for details."
          # Add alerting logic here (Slack, PagerDuty, etc.)
